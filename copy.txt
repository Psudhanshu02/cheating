# Load the images
    img1 = cv2.imread(image_paths[i], cv2.IMREAD_GRAYSCALE)
    img2 = cv2.imread(image_paths[i + 1], cv2.IMREAD_GRAYSCALE)

    # Compute the optical flow
    flow = cv2.calcOpticalFlowFarneback(img1, img2, None, 0.5, 3, 15, 3, 5, 1.2, 0)
    # print(flow.shape)
    # break

    # Convert flow to polar coordinates
    magnitude, angle = cv2.cartToPolar(flow[..., 0], flow[..., 1])

    # Create HSV image and populate it with the optical flow data
    hsv = np.zeros((img1.shape[0], img1.shape[1], 3), dtype=np.float32)
    hsv[..., 0] = angle * 180 / np.pi / 2
    hsv[..., 1] = 255
    hsv[..., 2] = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX)

    # Convert HSV to int32's
    hsv = np.asarray(hsv, dtype= np.float32)
    rgb_flow = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)
    
    img_tensor = torch.from_numpy(rgb_flow).unsqueeze(0).permute(0, 3, 1, 2).float()

    # Create a pointwise convolution to reduce the number of channels
    
    conv1x1 = nn.Conv2d(img_tensor.shape[1], 2, 1)
    
    # Manually set the weights
    weights = torch.tensor([[[[0.5]], [[0.5]], [[0.5]]],  # for the first output channel
                        [[[0.5]], [[0.5]], [[0.5]]]])  # for the second output channel
    conv1x1.weight = nn.Parameter(weights)
    #print(conv1x1.weight.shape)


    # Apply the convolution
    output = conv1x1(img_tensor)

    output=output.detach().numpy()
    #print(output.shape)
    

    # Save the optical flow image as a .npy file
    #np.save(f'/home/fatninja/Desktop/velocityEstimation/velocity_estimation_pretrained_model/numpy_files/optical_flow_image_{i}.npy', output)
