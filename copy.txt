import cv2
import numpy as np
import glob

# List of your image paths
image_paths = sorted(glob.glob('path_to_your_images/*.jpg'))

for i in range(len(image_paths) - 1):
    # Load the images
    img1 = cv2.imread(image_paths[i], cv2.IMREAD_GRAYSCALE)
    img2 = cv2.imread(image_paths[i + 1], cv2.IMREAD_GRAYSCALE)

    # Compute the optical flow
    flow = cv2.calcOpticalFlowFarneback(img1, img2, None, 0.5, 3, 15, 3, 5, 1.2, 0)

    # Convert flow to polar coordinates
    magnitude, angle = cv2.cartToPolar(flow[..., 0], flow[..., 1])

    # Create HSV image and populate it with the optical flow data
    hsv = np.zeros((img1.shape[0], img1.shape[1], 3), dtype=np.float32)
    hsv[..., 0] = angle * 180 / np.pi / 2
    hsv[..., 1] = 255
    hsv[..., 2] = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX)

    # Convert HSV to int32's
    hsv = np.asarray(hsv, dtype= np.float32)
    rgb_flow = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)

    # Save the optical flow image as a .npy file
    np.save(f'optical_flow_image_{i}.npy', rgb_flow)





# change dimention
import cv2
import torch
import torch.nn as nn

# Load image
img = cv2.imread("C:/Users/h560858/OneDrive - Honeywell/speed_detecton/vehicle-speed-estimation/1.png")

# Convert the image to PyTorch tensor and add an extra dimension for batch size
img_tensor = torch.from_numpy(img).unsqueeze(0).permute(0, 3, 1, 2).float()

# Create a pointwise convolution to reduce the number of channels
conv1x1 = nn.Conv2d(img_tensor.shape[1], 2, 1)

# Apply the convolution
output = conv1x1(img_tensor)

print(output.shape)
